# Java 基础

## 1、String、StringBuffer、StrngBuilder

String 的底层是`private final char value[]`，被 final 修饰，所以 String 对象是不可变的，是常量字符串。

StringBuffer 没有 final 修饰，是变量字符串。StringBuffer 有同步锁修饰，线程安全。

StringBuilder 没有 final 修饰，是变量字符串。StringBuilder 没有同步锁，线程不安全。

String 每次改变对象，实际上是在堆上新分配了一块空间用来存储修改后的值，然后 String 引用重新指向新的内存地址。StringBuffer 和 StringBuilder 每次修改都是修改的对象本身，不会生成新的对象。

**总结**

-   操作少量数据，用 String。
-   单线程操作大量数据，用 StringBuilder。
-   多线程操作大量数据，用 StringBuffer。

**final**

final 修饰的类不能被继承（成员方法不能被重写），final 修饰的方法不能被重写，final 修饰的变量只能赋值一次，无法被更改。

```java
class A {
    // 非final的类的final修饰的成员方法必须在实例化类的时候通过构造器的方式赋予初值，否则报错
    // 如果与final与static一起用，必须初始化。
    public final int a;
    A(int a) {
        this.a = a;
    }
}
```

final 修饰的变量在加载的时候必定要有初值！不加 static，变量属于每一个实例对象，实例对象都有自己的内存空间，可以在实例化的时候再赋值。加了 static，变量只属于类，并且编译期就会加载这个变量。记住：被 final 修饰的变量，用到的时候，一定要初始化！

## 2、重载（overload）和重写（overried）

重载：一个类中的同个方法根据不同的传参有不同的逻辑处理。重载一般发生在同类之中，参数类型、个数、顺序，方法返回值和访问修饰符可以不同。

**只有返回值不同的方法是重载吗？**

不是。因为虚拟机里识别重载的签名是按照**方法名加参数列表**，只有返回值不同，会编译出错。

重写：发生在运行期，子类对父类的可以访问的方法的实现过程进行重写编写。重写发生在父类与子类之间，方法名、参数列表、返回值均不能改变，不能抛出比父类更多的异常，不能缩小访问权限。

**带有 static 的方法能够重写吗？**

可以重载，但不可以重写。静态方法是类加载的时候就被加载到内存中的方法，在整个运行过程中保持不变，因而不能重写。但非静态方法是在对象实例化才单独申请空间，每一个实例化对象都有自己的独立的运行内存，因而可以重写。所谓的静态，指的是在类加载的时候，虚拟机就已经确定此静态方法或者静态属性属于哪个类。对于静态方法，只能隐藏、继承、重载。

隐藏：子类中定义的静态方法（类方法）与父类中静态方法（类方法）具有相同的返回值类型、方法名、方法参数的类型和个数完全相同，则称子类中的该方法“隐藏”了父类中的该方法。当子类创建的对象调用该隐藏方法时，默认调用的是子类中的方法。

## 3、接口和抽象类

**异：**

-   接口方法默认是 public，抽象类方法可以是 public、default、protected。
-   接口中只能有 static、final 修饰的变量，抽象类则没有这个规定。
-   类可以实现多个接口，但只能继承一个抽象类。

**同：**

-   都不能被实例化。
-   都能包含抽象方法。只用来描述类具备的功能，不提供具体实现。
-   都是上层抽象层。

## 4、char 能存储汉字吗？

能。java 采用 unicode 编码，char 变量是以 unicode 编码存储的。在 unicode 编码中，一个 char 类型占两个字节，我们的汉字也是两个字节，因而能够存储。前提条件是：该汉字被包含在 Unicode 编码字符集中！

## 5、异常

主要分为运行时异常和编译时异常。

## 6、Http 长连接和短连接

务必记住，长连接和短连接是指的 TCP 连接 !

-   长连接：没有数据传送也要保持 tcp 连接。
-   短连接：传输完数据就关闭 tcp 连接。

## 7、自己的 class 名字为 String 可以吗？

不可以，这是由于类加载机制决定的，类加载的双亲委派机制。某一个类要被加载，会被其委托给其父类进行加载，一层一层传递上去，直到启动类加载器进行统一加载。在父类的类加载器无法进行加载的情况下（范围搜索没有找到需要加载的类），才会到子类的加载器进行加载。很显然，自己定义的 String 类，即使是在 java.lang 包下，首先会调用到 appClassloader，继续向上委托到 extClassLoader，最后到 bootStrapClassLoader 进行加载。bootstraptClassLoader 负责加载 java 自己的核心内部类，所以 java 自带的 String 被加载，由于类加载的规则是重名不予加载，所以我们自定义的 String 不会被加载。

经过本人实验，发现，不同包的时候，class 名字定义为 String 完全没问题，jvm 会按照包+类名去加载我们定义的 String。但是，在 java.lang 包下，重新定义一个 String 类，在 jdk1.8 的情况下，没报错，但是默认使用的是 java 自带的 String 类，我们的 String 类根本就没有加载，根据类加载规则（详情见上一段），发现同名情况下不会再次加载。

补充：类加载的三个主要加载器：

bootstrap class loader：它用来加载 Java 的核心类。由 c++实现。

extensions class loader：它负责加载 JRE 的扩展目录，lib/ext 或者由 java.ext.dirs 系统属性指定的目录中的 JAR 包的类。 由 java 实现。

system class loader：被称为系统（也称为应用）类加载器，它负责在 JVM 启动时加载来自 Java 命令的-classpath 选项、java.class.path 系统属性，或者 CLASSPATH 换将变量所指定的 JAR 包和类路径。程序可以通过 ClassLoader 的静态方法 getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由 java 实现。
